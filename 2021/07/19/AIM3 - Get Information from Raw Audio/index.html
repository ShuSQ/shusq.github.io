<!DOCTYPE html>
<html lang="en">
    <!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
  
  <title>AIM3 - Getting Information from Raw Audio - Shu-Creative Computing</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/cursor.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
  
  
<link rel="stylesheet" href="/css/post.css">

  

<meta name="generator" content="Hexo 5.2.0"></head>


    <body>
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">Shu&#39;s Blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">Home</a>
            
            
            <a class="nav-item" href="/categories/essays">Thinking</a>
            
            
            
            <a class="nav-item" href="/categories/pcomp">Pcomp&amp;AVCE</a>
            
            
            
            <a class="nav-item" href="/categories/coding">Coding</a>
            
            
            
            <a class="nav-item" href="/categories/portfolio">Portfolio</a>
            
            
            
            <a class="nav-item" href="/contact">About</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/ShuSQ" target="_blank">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-codepen nav-item-icon" href="https://codepen.io/shusq" target="_blank">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-patreon nav-item-icon" href="https://www.instagram.com/cheese_shu/" target="_blank">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        <article class="post">
    <div class="meta">
        
        <div class="date" id="date">
            
            
            
            
            
            
            
            <span>July</span>
            
            
            
            
            
            
            <span>19,</span>
            <span>2021</span>
        </div>
        

        <h2 class="title">AIM3 - Getting Information from Raw Audio</h2>
    </div>

    <div class="divider"></div>

    <div class="content">
        <h3 id="Audio-basics"><a href="#Audio-basics" class="headerlink" title="Audio basics"></a>Audio basics</h3><p>Audio waveforms are lists of amplitude measurements than can be used to control the positions of a speaker in order to recreate observed pressure fluctuations.</p>
<p>They are generated by microphones by suspending a small filament of conductive material in an electromagnetic field and measuring its motion as sound passes over it.</p>
<p>You can also create them synthetically (e.g. with a sin function).</p>
<p>Usually we need to record 44,100 audio amplitude measurements each second in order to be able to reproduce sounds roughly the way we hear them.</p>
<p>Actually the number is sort of arbitrary as long as it’s more than twice the human hearing range (20,000 Hz as a rough max).</p>
<p>We usually store each of these amplitude values as a 16 bit value (as a minimum resolution).</p>
<p>This is why audio waveforms are usually lists of 16 or 32 bit values. They go between -1 and 1. This represents a normal range of speaker motion. When the speaker is moving out, the values are increasing above 0 to a maximum of 1, and when the speaker is moving in, it;s decreasing to a minimum of -1. However, -1 is just as ‘loud’ as 1 in these situations, as waveforms are bipolar and oscillate around 0.</p>
<h5 id="What-is-an-Audio-Feature"><a href="#What-is-an-Audio-Feature" class="headerlink" title="What is an Audio Feature?"></a>What is an Audio Feature?</h5><p>A form of information that you canderive from audio data that tells you something specific about the audio recording.</p>
<ul>
<li>E.g. how loud it is, where events might be, how noisy it is, if there are any musical features(pitches, sound types).</li>
</ul>
<h3 id="Audio-Buffer"><a href="#Audio-Buffer" class="headerlink" title="Audio Buffer"></a>Audio Buffer</h3><p>It’s common to use a short slice of audio data when generating or analysing audio signals. For example, when playing back a sound, you do not need to load the whole sound in to memory - you can just grab a short section. This is called ‘buffering’, and it’s used all the time in real-time audio. It’s cool because we can go through the audio in small chunks whilst we are listening to it, and graph the output at the same time. Otherwise we’d have to load the whole thing in and then wait for it to be processed before we can see it. This is cool for some things (and can actually be better), but it is less flexible.</p>
<h5 id="Getting-Information-out-of-Audio-Buffers"><a href="#Getting-Information-out-of-Audio-Buffers" class="headerlink" title="Getting Information out of Audio Buffers"></a>Getting Information out of Audio Buffers</h5><p>You can get information from an Audio Buffer very easily:</p>
<ul>
<li>You can just take a few values and try to understand what they mean</li>
<li>Or you can take the whole buffer and compute basic stats on them.</li>
</ul>
<p>The easiest thing to do is compute the average amplitude value, the peak amplitude value and the minimum amplitude value in the buffer. We are going to write an algorithm to get its average, minimum and maximum values.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assuming audioBuffer contains the audio buffer values</span></span><br><span class="line"><span class="comment">// and that bufferSize is the same as the number of values in the buffer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> avg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bufferSize; i++) &#123;</span><br><span class="line">  avg = avg + audioBuffer[i];</span><br><span class="line">&#125;</span><br><span class="line">avg = avg / bufferSize;</span><br><span class="line"><span class="built_in">console</span>.log(avg);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assuming audioBuffer contains the audio buffer values</span></span><br><span class="line"><span class="comment">// and that bufferSize is the same as the number of values in the buffer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> peak = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bufferSize; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> currentAmp = <span class="built_in">Math</span>.abs(audioBuffer[i]);</span><br><span class="line">  <span class="keyword">if</span> (currentAmpt &gt; peak) &#123;</span><br><span class="line">    peak = currentAmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(peak);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assuming audioBuffer contains the audio buffer values</span></span><br><span class="line"><span class="comment">// and that bufferSize is the same as the number of values in the buffer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> minimum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bufferSize; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> currentAmp = <span class="built_in">Math</span>.abs(audioBuffer[i]);</span><br><span class="line">  <span class="keyword">if</span> (currentAmpt &lt; minimum) &#123;</span><br><span class="line">    minimum = currentAmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(minimum);</span><br></pre></td></tr></table></figure>

<h3 id="Looking-for-events"><a href="#Looking-for-events" class="headerlink" title="Looking for events"></a>Looking for events</h3><p>So far the stats we have talked about ahve mainly told us about how loud things are in different ways.</p>
<p>We can use them to check the level of a signal, and probably control animations etc.</p>
<p>If the values in the audioBuffer cross a threshold value:</p>
<ul>
<li>e.g. &gt; 0.5 this might be an indication that an event has happened.</li>
</ul>
<p>But they also might be random fluctuations. We could use the average of the values in a chunk of audio to smooth the signal, and then test to see if the average value is over a certain amount. If it is, we could do something, like draw a box, or drop a maker. It is not very accurate, but it kind of works.</p>
<p>It is better if we do not smooth as we get a better measure of when thing actually happened. Butthis creates other problems. For example, what happens if we detect an event, and then the value of the audio waveform stays high or goes higher? We will get lots of false positives. This is common because a sound might start, and then get louder, but still be part of the same event.</p>
<p>What might we do to mitigate this?</p>
<ul>
<li>Solution 1: wait for the audio output todrop below a threshold before we allow it to go looking for new events.</li>
<li>Solution 2: set an amount of time that is the minimum duration between events - e.g. when an event is detected, start counting and do not allow any more events to be detected. After you have counted to a specific value, start looking for events again.</li>
</ul>
<p>One of the major issues here is that there are changes in audio that might be important, but that are not necessarily reflected in the amplitude values very strongly.</p>
<p>A musical melody might have lots of different pitches in it, but they might not look any different in terms of amplitude (unless they naturally have gaps between them).</p>
<p>So, importantly, what kind of information is this, and how can we go about finding it in the signal?</p>
<p>There are lots of ways of trying to extract frequency information from an audio buffer. The most important method is known as the Fourier ransform.</p>
<p>The fourier transform can tell you a lot about the universe, and provide you with spectral decompositions. The maths behind the transform are a bit off-topic for this session (I can point you at some details if you are interested).</p>
<p>But it is much more important to understand what information comes out of the Fourier transform, and how to create it!</p>
<h3 id="What-goes-in-what-comes-out-and-in-what-form"><a href="#What-goes-in-what-comes-out-and-in-what-form" class="headerlink" title="What goes in, what comes out, and in what form"></a>What goes in, what comes out, and in what form</h3><p>There’s a version of the Fourier Transform that is really efficient for real-time use, and it is called a Fast Fourier Transform.</p>
<p>It is useful because it provides us with lots of great information very quickly by only using a block size that is a power of 2.</p>
<p>This is cool because our audio blocksizes are usually also a power of 2. So we can just take our audio buffer and stick the whole thing in an FFT buffer.</p>
<p>It then gives us back a whole bunch of information about how the amplitude values intersect with sin and cosine waves over a range of different frequencies - thus giving us some idea what kind of frequencies are present in the data.</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*s6hST5ZNJ0pKKNebhx-A9Q.png"></p>
<p>The engineering behind how this works has lots of problems, for example: what happens if your audio buffer has lots of waveforms in it that are halfway through their period? Nasty.</p>
<p>In this case, we crossfade FFT buffers together in an ‘overlap-add’ process to reduce discontinuities. The more we do this, the better the result but this is not necessarily that important in information retrieval.</p>
<p>Also, the FFT produces twice as much data as you put in. This is pretty simple but not that important here because for most of things we are going to do, we won’t need all of it and we can simply throw it away.</p>
<p>What we need to know for now is that each pair of output values in the FFT array is the amount of energy in each frequency band expressed as two numbers - a complex number that represents a position on a 2D graph which you can think about as an x,y Cartesian plane - although it is considered a complex plane.</p>
<p>If we want to get the energy in each of these bands, we can do this by converting these two values (x,y) into a single magnitude value using a Pythagorean approach -x^2 + y^2 = mag^2.</p>
<p>The output of this is a simgple value which contains just the energy in each band.</p>
<p>The even better news is that we only actually need half of this data - the first half of the array. So we can throw the other half away.</p>
<p>We call this a real FFT, or rFFT. Most of what we are going to do only needs the rFFT. It is half the size of the data we put in, and a quarter of the size.</p>
<p>SO what does each value in a real FFT (rFFT) really mean?</p>
<p>well, given a samplerate of 44100, you can get the width of each band by dividing 44100 by the size of the audio buffer.</p>
<p>This is also known as the Bin Frequency. Each value in the array (number in the list) represents energy in a specific bandwidth equal to the bin frequency.</p>
<p>So in real terms, with a samplerate of 44100, and an FFT size of 1024, your bin frequency is 44100/1024 = 43.06640625Hz.</p>
<p>You might notice that half the FFT rate, the bin frequency is &gt; 22050, which is why we only need half the data. The second half of the output is actually just a mirror image of what you will find in first half, which is why we do not need it.</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*vQizyCrAcZgPrAoBSr9Xzw.png"></p>
<h3 id="FFT-statistics"><a href="#FFT-statistics" class="headerlink" title="FFT statistics"></a>FFT statistics</h3><p>SO we have an array of values that tell you what spectral energy is in a chunk of audio. It can tell you about the frequency distribution of the waveforms in the signal. We can use this to create an audio ‘fingerprint’ of any sound. Most FFT frames are less similar than you think.</p>
<p>So once we have the list of values, we can do the same things with it that we just talked about:</p>
<ul>
<li><p>We can get the average, the lowest val, the highest val, the standard deviation.</p>
</li>
<li><p>We can get the absolute difference between consecutive frames, and then get the average of this difference. This is called ‘spectral FLUX’. It is great because it can be used to capture note events, as note events are often changes in frequency.</p>
</li>
</ul>
<p>FFTs are great, but they do have a couple of issues. The FFT gives us a linear output, meaning that doublings of frequency are spread futher and further apart in the data. This is not how we usually hear sounds. If we double the frequency of a musical note, we hear it as octave up, and to us, and octave is not much. If we double it again, we also hear it a further octave up - the smae distance, and we recognize it as the same note. But in the FFT they are represented further apart each time.</p>
<h5 id="CQT"><a href="#CQT" class="headerlink" title="CQT"></a>CQT</h5><p>The constant Q transform (CQT) takes the FFT and reduces it to a much smaller number of values, like say, 128.</p>
<p>We don’t need to know precisely how this happens. Yes it is a loop, we need to take energy from some of thebins and stick it in fewer bins, we need to have a rationale of how and hwy to do this.</p>
<p>Usually the rationale used is octaves, where Q is thebandwidth in ‘logaritmic’ frequency, so that an octave is spaced out evenly across the bins.</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*E-oPdJI7QRiwTtT922J-mQ.png"></p>
<h5 id="MFCC"><a href="#MFCC" class="headerlink" title="MFCC"></a>MFCC</h5><p>This is the best audio feature if you want to create a small audio fingerprint.</p>
<p>We can take a CQT and then do a consine transform on it (half an FFT). This will give us a msall ‘spectrum of a spectrum’.</p>
<p>Also called CEPSTRUM, this can be much smaller than an FFT (as small as 12 numbers) and be much better in some ways:</p>
<ul>
<li>More robust to noise and amplitude variations.</li>
<li>Easier to store and access</li>
<li>Quicker to search through</li>
</ul>
<p>If we convert a bunch of FFT frames to cepstrum frames, this is a great way of matching audio!</p>
<p>FFT / MFCC visualiser <a target="_blank" rel="noopener" href="https://mimicproject.com/code/ee2fbb9e-f474-fb4e-033d-7453fd05c043">https://mimicproject.com/code/ee2fbb9e-f474-fb4e-033d-7453fd05c043</a> </p>
<p>MFCC Classifier Demo <a target="_blank" rel="noopener" href="https://mimicproject.com/code/3864f3e5-8263-b70e-5ef9-1037c724d4ec">https://mimicproject.com/code/3864f3e5-8263-b70e-5ef9-1037c724d4ec</a> </p>
<p>MFCC -&gt; Learner.js – great example to build on <a target="_blank" rel="noopener" href="https://mimicproject.com/code/7b2ab7db-77a2-ce81-da66-d805126098c6">https://mimicproject.com/code/7b2ab7db-77a2-ce81-da66-d805126098c6</a></p>

    </div>

    <div class="about">
        <h1>About this Post</h1>
        <p>This post is written by Siqi Shu, licensed under <a
                target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
    </div>
</article>
        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h4 class="title">深智一物 眾隱皆變</h4>
                
            </div>
            
        </div>
        &copy; 2024 Siqi Shu<br />
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
</footer>


        
<script src="/js/main.js"></script>

        
<script src="/js/kursor.js"></script>

        
<script src="/js/run.js"></script>


    </body>
</html>
